import React, { useEffect, useState } from "react";
import {
  RemHierarchyEditorTree,
  RemId,
  RemViewer,
  renderWidget,
  usePlugin,
  useSyncedStorageState,
} from "@remnote/plugin-sdk";
import { timeSince } from "../lib/utils";

const NUM_TO_LOAD_IN_BATCH = 20;
export interface RemHistoryData {
  key: number;
  remId: RemId;
  open: boolean;
  time: number;
  kbId?: string; // Added kbId
  text?: string; // text content for search
  _v?: number; // version for cache invalidation
}

function RightSidebar2() {
  const plugin = usePlugin();
  const [remDataRaw, setRemData] = useSyncedStorageState<RemHistoryData[]>(
    "remData",
    []
  );

  const [filteredRemData, setFilteredRemData] = useState<RemHistoryData[]>([]);

  // Search State
  const [searchText, setSearchText] = useState("");

  // Backfill Effect: Fetch text for items that don't have it
  useEffect(() => {
    let mounted = true;
    async function backfillData() {
      // Find items needing backfill (missing text OR old version)
      const needsBackfill = remDataRaw
        .filter(item => typeof item.text === 'undefined' || item._v !== 1)
        .slice(0, 5); // Batch size to avoid overload

      if (needsBackfill.length === 0) return;

      const updates = new Map<number, string>();

      for (const item of needsBackfill) {
        const rem = await plugin.rem.findOne(item.remId);
        const frontText = rem?.text ? await plugin.richText.toString(rem.text) : "";
        const backText = rem?.backText ? await plugin.richText.toString(rem.backText) : "";
        const text = `${frontText} ${backText}`.trim();
        updates.set(item.key, text);
      }

      if (!mounted) return;

      // Batch update
      setRemData(
        remDataRaw.map(item => {
          if (updates.has(item.key)) {
            return { ...item, text: updates.get(item.key), _v: 1 };
          }
          return item;
        })
      );
    }

    // Run periodically if there are items effectively
    if (remDataRaw.some(x => typeof x.text === 'undefined' || x._v !== 1)) {
      const timer = setTimeout(backfillData, 1000);
      return () => clearTimeout(timer);
    }
  }, [remDataRaw, plugin]);

  // Effect to filter data by Knowledge Base AND Search Text
  useEffect(() => {
    async function filterData() {
      const currentKb = await plugin.kb.getCurrentKnowledgeBaseData();
      const isPrimary = await plugin.kb.isPrimaryKnowledgeBase();
      const currentKbId = currentKb._id;

      let filtered = remDataRaw.filter((item) => {
        if (!item.kbId) {
          // Legacy: Include if this is the Primary KB
          return isPrimary;
        }
        // New: Include if KB ID matches
        return item.kbId === currentKbId;
      });

      // 2. Search Filter
      if (searchText.trim().length > 0) {
        const lowerSearch = searchText.toLowerCase();
        const tokens = lowerSearch.split(/\s+/).filter(t => t.length > 0);

        filtered = filtered.map(item => {
          if (!item.text) return { item, score: 0 };
          const lowerText = item.text.toLowerCase();

          let score = 0;
          for (const token of tokens) {
            if (lowerText.includes(token)) {
              score++;
            }
          }
          return { item, score };
        })
          .filter(x => x.score > 0)
          .sort((a, b) => {
            // Sort by matches (desc), then by time (desc)
            if (b.score !== a.score) return b.score - a.score;
            return b.item.time - a.item.time;
          })
          .map(x => x.item);
      }

      setFilteredRemData(filtered);
    }
    filterData();
  }, [remDataRaw, plugin, searchText]);

  const closeIndex = (itemKey: number) => {
    const originalIndex = remDataRaw.findIndex(x => x.key === itemKey);
    if (originalIndex !== -1) {
      remDataRaw.splice(originalIndex, 1);
      setRemData([...remDataRaw]);
    }
  };

  const setData = (itemKey: number, changes: Partial<RemHistoryData>) => {
    const originalIndex = remDataRaw.findIndex(x => x.key === itemKey);
    if (originalIndex !== -1) {
      const oldData = remDataRaw[originalIndex];
      const newData = { ...oldData, ...changes };
      remDataRaw.splice(originalIndex, 1, newData);
      setRemData([...remDataRaw]);
    }
  };

  const [numLoaded, setNumLoaded] = React.useState(1);

  useEffect(() => {
    setNumLoaded(1);
  }, [filteredRemData.length]);

  const numUnloaded = Math.max(
    0,
    filteredRemData.length - NUM_TO_LOAD_IN_BATCH * numLoaded
  );

  return (
    <div
      className="h-full w-full overflow-y-auto rn-clr-background-primary"
      onMouseDown={(e) => e.stopPropagation()}
    >
      <div className="p-2 text-lg font-bold">Visited Rem History</div>
      <div className="px-2 pb-2">
        <input
          className="w-full p-2 border rounded-md rn-clr-background-secondary rn-clr-content-primary border-gray-200 focus:ring-2 focus:ring-blue-500 focus:outline-none"
          placeholder="Search history..."
          value={searchText}
          onChange={(e) => setSearchText(e.target.value)}
        />
      </div>
      {filteredRemData.length == 0 && (
        <div className="rn-clr-content-primary">
          Navigate to other documents to automatically record history.
        </div>
      )}
      {filteredRemData.slice(0, NUM_TO_LOAD_IN_BATCH * numLoaded).map((data, i) => (
        <RemHistoryItem
          data={data}
          remId={data.remId}
          key={data.key || Math.random()}
          setData={(c) => setData(data.key, c)}
          closeIndex={() => closeIndex(data.key)}
        />
      ))}
      {numUnloaded > 0 && (
        <div
          onMouseOver={() => setNumLoaded((i) => i + 1)}
          className="pb-[200px]"
        >
          {" "}
          Load more{" "}
          <span className="rn-clr-content-secondary">({numUnloaded})</span>
        </div>
      )}
    </div>
  );
}

// ... RemHistoryItem interface and component remain unchanged ...
interface RemHistoryItemProps {
  data: RemHistoryData;
  remId: string;
  setData: (changes: Partial<RemHistoryData>) => void;
  closeIndex: () => void;
}

function RemHistoryItem({
  data,
  remId,
  setData,
  closeIndex,
}: RemHistoryItemProps) {
  const plugin = usePlugin();

  const openRem = async (remId: RemId) => {
    const rem = await plugin.rem.findOne(remId);
    if (rem) {
      plugin.window.openRem(rem);
    }
  };

  return (
    <div className="px-1 py-4 w-full" key={remId}>
      <div className="flex gap-2 mb-2">
        <div
          className="flex items-center justify-center flex-shrink-0 w-6 h-6 rounded-md cursor-pointer hover:rn-clr-background--hovered"
          onClick={() => setData({ open: !data.open })}
        >
          <img
            src={`${plugin.rootURL}chevron_down.svg`}
            style={{
              transform: `rotate(${data.open ? 0 : -90}deg)`,
              transitionProperty: "transform",
              transitionTimingFunction: "cubic-bezier(0.4, 0, 0.2, 1)",
              transitionDuration: "150ms",
            }}
          />
        </div>
        {/* min-w-0 prevents overflow */}
        <div className="flex-grow min-w-0" onClick={() => openRem(remId)}>
          <RemViewer
            remId={remId}
            constraintRef="parent"
            width="100%"
            className="font-medium cursor-pointer line-clamp-2"
          />
          <div className="text-xs rn-clr-content-tertiary">
            {timeSince(new Date(data.time))}
          </div>
        </div>
        <div
          className="flex items-center justify-center flex-shrink-0 w-6 h-6 rounded-md cursor-pointer hover:rn-clr-background--hovered"
          onClick={closeIndex}
        >
          <img
            src={`${plugin.rootURL}close.svg`}
            style={{
              display: "inline-block",
              fill: "var(--rn-clr-content-tertiary)",
              color: "color",
              width: 16,
              height: 16,
            }}
          />
        </div>
      </div>
      {data.open && (
        <div className="m-2" style={{ borderBottomWidth: 1 }}>
          <RemHierarchyEditorTree height="auto" width="100%" remId={remId} />
        </div>
      )}
    </div>
  );
}

renderWidget(RightSidebar2);